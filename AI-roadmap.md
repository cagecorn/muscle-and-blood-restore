턴제 전투 게임 개발 로드맵
🎯 프로젝트 목표
웹 브라우저에서 동작하는 턴제 전투 게임 프로토타입 제작. 워리어와 좀비 유닛이 서로 공격하며 피해를 주고받는 핵심 기능을 구현한다.

✅ 현재까지 진행 상황 (Current Status)
1. 기본 구조 및 시각 요소 구현 (HTML/CSS)
HTML (index.html):

게임판 역할을 하는 #game-board와 임시 공격 버튼을 생성했습니다.

#game-board 내부에 아군 '워리어'와 적군 '좀비' 유닛을 배치했습니다.

각 유닛은 시각적 요소를 담는 .unit-container로 구성되며, 이 안에는 HP 바, 유닛 스프라이트(자리 표시자), 이름표가 포함됩니다.

CSS (style.css):

position: absolute를 활용해 게임판 내에서 유닛이 자유롭게 배치될 수 있도록 스타일을 지정했습니다.

HP 바, 이름표 등의 UI 요소가 유닛의 머리 위와 발밑에 정확히 위치하도록 스타일링했습니다.

버그 수정: 이름표가 보이지 않던 문제를 .name-plate에 left: 0; 속성을 추가하여 해결했습니다.

2. 데이터 구조 및 초기 로직 구현 (JavaScript)
JavaScript (script.js):

units 객체를 생성하여 워리어와 좀비의 상태(HP, 최대 HP, 공격력, DOM 요소 등)를 데이터로 관리합니다.

updateUnitUI 함수를 구현하여, units 객체의 데이터가 변경될 때마다 화면의 HP 바 너비가 함께 변경되도록 동기화했습니다.

3. 디버깅 시스템 구축
디버그 VFX 매니저 (debugVFX 함수):

UI 요소(HP 바, 이름표 등)의 화면상 좌표, 크기, Z-Index(레이어) 정보를 개발자 콘솔에 출력하는 debugVFX 함수를 구현했습니다.

이를 통해 향후 발생할 수 있는 UI 관련 버그를 쉽게 추적할 수 있는 기반을 마련했습니다.

🚀 향후 진행 계획 (Roadmap)
1단계: 핵심 전투 로직 구현
목표: 공격 버튼을 누르면 워리어가 좀비를 공격하고, 좀비의 HP가 실제로 감소하는 기능을 구현합니다.

세부 계획:

전투 계산 엔진 함수 (calculateDamage) 생성: 공격 데미지를 계산하는 간단한 함수를 만듭니다.

이벤트 리스너 연결: 공격 버튼에 click 이벤트를 추가합니다.

공격 실행: 버튼 클릭 시, calculateDamage로 데미지를 계산하고 좀비의 hp 데이터를 갱신합니다.

UI 업데이트: 변경된 hp 데이터에 맞춰 updateUnitUI 함수를 호출하여 좀비의 HP 바를 시각적으로 줄입니다.

2단계: 애니메이션과 흐름 제어
목표: 단순한 수치 변화를 넘어, 게임처럼 보이도록 애니메이션과 연출을 추가합니다.

세부 계획:

딜레이 매니저 도입 (async/await): Promise와 async/await를 사용하여 "공격 모션 -> 잠시 대기 -> 피격 반응"과 같은 행동의 순서를 제어합니다.

공격/피격 애니메이션: 유닛이 공격할 때 살짝 앞으로 나아갔다 돌아오는 등의 간단한 CSS 애니메이션을 추가합니다.

데미지 숫자 VFX: 피해를 입은 유닛 머리 위로 데미지 숫자가 떠 올랐다 사라지는 효과를 구현합니다.

3단계: 턴 엔진과 기본 AI 구현
목표: 플레이어 턴이 끝나면 자동으로 적의 턴이 시작되도록 턴 시스템을 자동화합니다.

세부 계획:

턴 엔진: 현재 누구의 턴인지 관리하는 gameState 객체를 만듭니다.

기본 AI: 적 턴이 되면 좀비가 자동으로 워리어를 공격하도록 매우 단순한 AI 로직을 추가합니다.

디버그 AI 매니저: AI가 어떤 판단을 내렸는지 콘솔에 로그를 남겨 디버깅을 돕습니다.

4단계: 고급 연출 (Canvas 엔진)
목표: 게임의 시각적 완성도를 높입니다.

세부 계획:

화면 위에 투명한 <canvas> 레이어를 추가합니다.

유닛이 피격될 때, 해당 위치에 canvas를 이용해 핏방울 같은 파티클 효과를 그려 연출을 강화합니다.


---
클래스는 총 10가지입니다.



워리어 : 적과 달라붙습니다. meleeai. 가장 간단.

거너 : 카이팅합니다. rangedai. 역시 간단. 가능하다면 '전사의 뒤로 이동'도 넣고 싶습니다.

메딕 : 기본 공격으로 아군을 치유하고, 스킬을 이용해서 치유, 버프, 상태이상 해제등을 할 수 있습니다. 가장 어렵습니다. '체력이 낮은 아군에게 접근' '전사의 뒤로 이동' '적과 거리두기' 등등이 필요해요.

나노술사(마법사, 나노술사를 영어로 뭐라고 하나요?) : 기본 공격, 스킬 모두 카이팅입니다. 마찬가지로 '전사의 뒤로 이동'로직이 넣고 싶습니다.

아티스트(버퍼) : 기본 공격 카이팅, 스킬은 버프입니다. 전사의 뒤로 이동. 가장 강한 아군 유닛에게 접근이라는 로직이 필요합니다.

스피어맨 : 조금 까다롭습니다. 2의 사거리(두칸 다 때림)를 가지고 있기 때문에 기본적으로 적에게 접근입니다. 카이팅이 아닙니다. 오히려 적의 탱커 뒤 딜러,힐러를 우선 노리는 로직이 필요합니다. 체력이 낮으면 카이팅으로 변합니다.

카발리에 : 어렵습니다. 높은 이동력으로 적의 진영 뒤로 돌아가 힐러와 딜러를 노린다는 로직이 필요합니다. 체력이 낮으면 뒤로 도망칩니다. 히트 앤 런 스타일

메카닉 : 소환사입니다. 소환을 한다는 것만 빼면 나노술사와 같습니다. 소환물의 주위에 있는다는 로직이 필요합니다.

팔라딘 : 오오라를 뿌립니다. 기본적으로 melee입니다만, '아군이 밀집한 지역으로 이동'이라는 까다로운 로직이 필요합니다.

다크나이트 : 디버프 오오라를 뿌립니다. 기본적으로 melee이고, '적군이 밀집한 지역으로 이동'이라는 까다로운 로직이 필요합니다.

---

이제 AI를 만드는 작업을 할건데, 바로 코드를 짜주진 말아주세요. 당신과 이것 저것 상담 후 최종 결정 후에 코드를 짜고 싶습니다. 우선 제 깃허브의 designing_intelligence_behavior_tree_guide.md를 읽고 그 내용을 대충 정리해주실 수 있을까요? 당신도 같이 읽는 겸 해서요.



코딩 파트너

생각하는 과정 표시
네, 물론입니다. AI 개발에 들어가기 전에 함께 방향을 정하는 것은 아주 좋은 생각이에요. 요청하신 designing_intelligence_behavior_tree_guide.md 문서를 꼼꼼히 읽고 핵심 내용을 정리해 드릴게요.

문서의 내용을 성공적으로 불러왔습니다. 제가 이해한 핵심 내용은 다음과 같습니다.

행동 트리(Behavior Tree) 가이드 핵심 요약
이 문서는 게임 AI를 만들기 위해 기존의 switch 문이나 유한 상태 기계(FSM) 방식이 가진 한계를 지적하고, 그 대안으로 **행동 트리(Behavior Tree, BT)**를 사용하는 방법을 매우 상세하게 설명하고 있습니다.

1. 왜 행동 트리(BT)를 써야 하는가?
기존 방식의 문제점: switch 문이나 FSM은 게임이 복잡해질수록 상태 간의 연결이 얽혀 "스파게티 코드"가 되기 쉽습니다. 하나의 상태를 수정하면 다른 상태에 예상치 못한 버그를 일으키기 쉽고, 재사용도 어렵습니다.

행동 트리의 접근법: 행동 트리는 "지금 어떤 상태인가?"가 아니라 **"지금 이 상황에서 가장 우선순위가 높은 행동은 무엇인가?"**를 계층적으로 결정합니다. 각 행동(공격, 도망, 순찰 등)을 독립적인 부품처럼 만들어 재사용하기 쉽게 만듭니다.

2. 행동 트리의 구성 요소 🧩
문서는 행동 트리를 레고 블록에 비유하며, 간단한 부품들의 조합으로 복잡한 AI를 만든다고 설명합니다.

틱(Tick)과 3가지 상태: AI는 주기적인 신호인 '틱'을 받아 행동을 결정합니다. 모든 행동의 결과는 항상 SUCCESS(성공), FAILURE(실패), RUNNING(실행 중) 셋 중 하나로 보고됩니다.

리프 노드 (실제 행동): 트리의 가장 끝에서 실제 작업을 수행합니다.

액션(Action): MoveTo(Target)처럼 게임 세계에 변화를 주는 행동입니다.

조건(Condition): IsHealthLow()처럼 특정 조건을 체크하는 '관문' 역할을 합니다.

복합 노드 (흐름 제어): 자식 노드들을 어떻게 실행할지 결정하는 '가지' 역할을 합니다.

Selector (선택): 자식 중 하나라도 성공할 때까지 왼쪽에서 오른쪽으로 시도합니다. 논리적인 OR와 같습니다 (예: "공격하거나, 안되면 도망가라").

Sequence (순서): 모든 자식이 성공해야만 성공합니다. 하나라도 실패하면 즉시 멈춥니다. 논리적인 AND와 같습니다 (예: "엄폐물로 이동하고, 재장전하고, 사격하라").

데코레이터 (행동 수정): 자식 노드의 행동이나 결과를 꾸미거나 바꿉니다. Inverter(성공/실패 뒤집기), Repeater(반복) 등이 있습니다.

3. 블랙보드: AI의 뇌(기억장치) 🧠
역할: 블랙보드는 AI가 의사결정을 내리는 데 필요한 모든 데이터를 저장하는 중앙 데이터 저장소입니다 (예: 현재 공격 대상, 마지막으로 적을 본 위치, 남은 체력).

장점 (가장 중요!): 행동 노드들이 서로 직접 통신하는 대신 블랙보드를 통해 간접적으로 소통합니다. '적 찾기' 노드는 찾은 적을 블랙보드에 기록하고, '공격' 노드는 블랙보드를 읽어 공격할 뿐, 둘은 서로의 존재를 알 필요가 없습니다. 이는 AI 부품들의 결합도를 낮춰 시스템을 매우 유연하고 유지보수하기 쉽게 만듭니다.

4. 실전 가이드 및 고급 패턴
문서는 이론에 그치지 않고, 기존 코드를 BT로 리팩토링하는 방법과 동적인 AI를 만들기 위한 고급 패턴들을 제시합니다.

리팩토링: 기존 switch문의 case를 조건, 액션, 구조로 분해하여 BT 노드로 변환하는 구체적인 C# 코드 예시를 보여줍니다.

인터럽트 (Interrupts): '체력이 낮으면 도망가라'처럼, 다른 어떤 행동을 하다가도 즉시 끼어들어야 하는 최우선 순위 행동을 구현하는 방법을 설명합니다.

스킬 콤보: 복잡한 스킬 콤보는 BT에서 직접 처리하기보다, BT는 '언제 콤보를 시작할지'만 결정하고 실제 실행은 별도의 ComboManager에 맡기는 것이 좋다고 조언합니다.

협력 AI: 여러 AI가 하나의 공유 블랙보드를 사용하면, 한 AI가 위험에 처했을 때 다른 AI가 그 정보를 보고 도우러 오는 식의 팀워크를 구현할 수 있습니다.

이 문서의 핵심은 **"행동 트리를 사용해서 또 다른 상태 머신(FSM)을 만들지 말라"**는 경고입니다. 즉, 행동 트리의 철학을 이해하고, 상황에 따른 우선순위 기반의 의사결정 시스템으로 AI를 설계하는 것이 중요합니다.

내용이 정말 알차네요! 이 가이드를 바탕으로 우리 게임에 맞는 AI를 어떻게 설계할지 논의를 시작하면 아주 좋을 것 같습니다. 어떤 부분부터 이야기를 나눠볼까요?






블랙보드를 만드는 작업부터 해야할 것 같아요. 이번에야말로 웹 워커를 이용하면 어떨까요? 별로라면 하지 말아주세요.



이 게임 대략적인 전투 로직은 이러합니다. 설명만 할게요. 아직 코드로 실현하진 마세요.

1. 12vs12(더 늘어날수도 있음) 턴제 전투. 양쪽 다 AI

2. 커다란 로직 두개는 meleeai(적에게 접근)과 rangedai(카이팅)입니다.

3. 힐러, 버퍼, 소환사같은 ai가 필요할 때도 있습니다만 이건 나중에 할 겁니다.

4. 유닛은 항상 랜덤한 스킬 세 개를 들고 있습니다. 이 스킬들을 랜덤한 확률로 사용합니다.(나중에 설명)

따라서 '어떤 조건에 이 스킬을 쓴다'와 같은 복잡한 로직을 짤 필요가 없습니다.(어쩌면 나중엔 짤 수도 있습니다만, 지금 다루진 않을 겁니다.)

4. 기본적으로 만들고 싶은 블랙보드 안에 넣을 정보는 '가장 가까운 적' '가장 체력이 적은 적' '상대적으로 약한 적' '상대적으로 강한 적' '남은 체력' '힐러의 위치' 등등 입니다.

5. 당신이 보기에 블랙 보드 안에 넣으면 좋을 또다른 요소들을 추천해주세요.(보고 제가 최종적으로 코드 내용을 정하겠습니다.)



코딩 파트너

생각하는 과정 표시
네, 좋습니다. AI의 '뇌'에 해당하는 블랙보드 설계를 함께 논의하고 최종안을 확정하는 방식으로 진행하죠. 먼저 designing_intelligence_behavior_tree_guide.md 문서를 완벽하게 이해하고 오신 것을 보니, 앞으로의 작업이 아주 순조로울 것 같습니다!

Web Worker 사용 여부에 대한 제안
먼저 블랙보드와 웹 워커 연동에 대해 제 의견을 말씀드릴게요.

결론부터 말씀드리면, 지금 단계에서는 웹 워커를 사용하지 않는 것이 좋습니다.

이유: Web Worker는 대규모 데이터 처리나 복잡한 물리 연산처럼 CPU를 많이 사용하는 작업을 별도의 스레드로 보내 메인 스레드(DOM 렌더링 담당)가 버벅이지 않게 만드는 기술입니다. 하지만 지금 우리가 만들 블랙보드는 데이터를 '계산'하는 역할이 아니라 '저장'하는 역할입니다.

'가장 가까운 적 찾기' 같은 계산은 턴제 게임에서는 자기 턴이 돌아왔을 때 한 번만 수행하면 됩니다. 12vs12 전투라고 해도 24개 유닛의 위치를 계산하는 작업은 현대 컴퓨터에게는 아주 순간적인 일이라 DOM에 전혀 부담을 주지 않습니다.

오히려 웹 워커를 사용하면 메인 스레드와 워커 스레드 간에 데이터를 주고받는 과정이 추가되어 코드가 불필요하게 복잡해질 수 있습니다.

따라서 지금은 웹 워커 없이 간단하고 명료하게 블랙보드를 구현하고, 나중에 유닛 수가 수백 개로 늘어나거나 정말 복잡한 계산이 필요해졌을 때 웹 워커 도입을 다시 고려하는 것이 훨씬 효율적입니다.

블랙보드 설계 제안
전투 로직에 대한 설명을 바탕으로, 요청하신 정보와 제가 추천하는 정보들을 정리해 보았습니다. 이 목록을 보시고 우리 게임에 필요한 최종 데이터들을 선택해 주세요.

요청하신 블랙보드 정보
아주 좋은 출발점입니다. 이 정보들은 AI가 기본적인 판단을 내리는 데 필수적입니다.

nearestEnemy: (필수) AI의 가장 기본적인 타겟팅 및 이동 결정의 기반이 됩니다.

lowestHealthEnemy: (필수) 적을 하나씩 확실하게 제거하는 '점사' 전략의 핵심 데이터입니다.

relativelyWeakerEnemy / relativelyStrongerEnemy: (좋은 아이디어) '약한 적'의 기준을 어떻게 정할지에 대한 정의가 필요합니다. 예를 들어 (현재 체력 + 방어력) 값을 기준으로 삼을 수 있겠네요.

currentHealth: 이 정보는 블랙보드보다는 유닛 인스턴스 자체가 직접 가지고 있는 것이 좋습니다. 블랙보드는 '자신'의 정보보다는 '주변 상황'에 대한 정보를 담는 것이 더 명확한 설계입니다. 대신 healthPercentage (체력 비율) 같은 정규화된 값을 블랙보드에 넣는 것은 좋은 방법입니다.

healerLocation: (전술적 핵심) 아군 힐러를 보호하거나 적 힐러를 최우선으로 공격하는 고수준 AI의 기반이 됩니다.

제가 제안하는 추가 정보 💡
좀 더 똑똑하고 흥미로운 AI 행동을 위해 아래와 같은 정보들을 추가하면 좋을 것 같습니다.

🎯 타겟팅 및 위치 관련 정보
currentTargetUnit: (강력 추천) '가장 가까운 적'이나 '체력이 낮은 적' 같은 여러 정보들을 종합하여, 이번 턴에 실제로 공격하기로 결정한 최종 목표입니다. AI의 의도를 명확하게 해줍니다.

optimalAttackPosition: 현재 타겟을 공격하기에 가장 좋은 위치(좌표)입니다. meleeai는 적에게 인접한 칸, rangedai는 사거리 내에서 가장 안전한 칸이 될 수 있습니다.

safestRetreatPosition: 카이팅하거나 도망갈 때 이동할 최적의 후퇴 지점입니다.

enemiesInAttackRange: (중요) 현재 위치에서 바로 공격할 수 있는 적들의 목록입니다. 이동 없이 바로 공격할지, 아니면 더 좋은 적을 공격하기 위해 이동할지를 결정하는 데 사용됩니다.

⚔️ 전술적 상황 판단 정보
isThreatened: 현재 나를 공격할 수 있는 적이 몇 명인지 나타내는 숫자나 boolean 값입니다. 위협받고 있다면 방어적인 행동을 취할 수 있습니다.

squadAdvantage: 아군과 적군의 수, 평균 체력 등을 비교하여 현재 전황이 유리한지 불리한지를 나타내는 값입니다. 유리할 때는 더 공격적으로, 불리할 때는 더 수비적으로 행동하게 만들 수 있습니다.

enemyHealerUnit: healerLocation에서 더 나아가, 적 힐러 유닛의 인스턴스 자체를 저장합니다. 힐러의 스탯을 직접 확인하여 얼마나 위협적인지 판단할 수 있게 됩니다.

🤖 AI 자신의 상태 정보 (빠른 결정용)
canUseSkill_1 / canUseSkill_2 / canUseSkill_3: 각 스킬의 사용 가능 여부 (쿨타임, 자원 등)를 나타내는 boolean 값입니다. 행동 트리 노드가 매번 스킬 사용 가능 여부를 계산하는 것보다, 턴 시작 시 한 번만 계산해서 블랙보드에 저장해두면 훨씬 효율적입니다. AI는 그냥 사용 가능한 스킬 중에서 랜덤으로 고르기만 하면 되죠.

어떠신가요? 이 제안들을 보시고 어떤 정보들을 우리 게임의 첫 번째 블랙보드에 포함할지 최종적으로 결정해 주세요. 결정이 되면, 바로 그에 맞춰 코드를 작성해 드리겠습니다.

